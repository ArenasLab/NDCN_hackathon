---
title: "Arenas lab name checker usage"
author: "Oliver Tam and Julie Lowndes"
date: "6/26/2020"
output: html_document
---

## Introduction

This document is to keep track of our workflow using `name_checker.R`,
a script to check that files conform to the Arenas lab convention: 

We expect 8 sections, each separated by an underscore `_`:

1. Experimental name and researcher initials
2. Experiment date and experiment number
3. Condition and replicate number
4. Immunohistochemistry date
5. Dye, antibodies or transcript
6. Image capture date
7. Microscope type
8. Lens, zoom and image number

The first 3 sections would be used (in a future script) to sort the
file into subfolders

Example:

`NES-SAI2d15-CS_200514-01_Vehicle-1_200517_DAPI+goPitx3-dk488+rbAldh1-dk555+moTh-dk647_200519_CF_10Xz1-1.tiff`

Where:

- Experiment name & initial: `NES-SAI2d15-CS`. experiment name is NES-SAI2d15, CS is Carmen Salto
- Experiment date and number: `200514-01`. 14 May 2020, number 1
- Condition & replicate: `Vehicle-1`. Vehicle condition, replicate 1
- Immunohistochemistry date: `200517`: 17 May 2020
- Dye/antibodies/transcript: `DAPI+goPITX3-dk488+rbALDH1-dk555+moTH-dk647`. Each element separated by `-`, if multiple separated by `+`
- Image capture date: `200520`: 20 May 2020
- Microscope type: `CF`. Confocal microscope 
- Lens, zoom & image number: `10X-z2-3`. 10x lens, 2 zoom, number 3.

## Code setup

Download or clone the GitHub folder. Move it somewhere you do your analyses (we can discuss good options later).

Open the GitHub folder from RStudio File > Open Project... or in Finder/Windows Explorer by double-clicking the `NDCN_hackathon.Rproj` file.

Navigate to the "arenas-02" folder.

We will work from this `name_checker_usage.Rmd` document today. It is
an R Markdown document, which combines simple text and R code. You can
use the Table of Contents at the bottom of the file to navigate. And
please add your own notes!

We will load one library, `here`, which reduces potential filepath issues.

```{r setup}
## checks if the `here` package is installed, if not, installs 
if(! requireNamespace("here",quietly=TRUE)){
  install.packages("here")
}

## load libraries
library(here) # load `here` package
```

## How to use the `name_checker` function

First we have to tell R we want to access code in the `name_checker.R` file, which we do with the `source()` function. This R script has a function called `name_checker()` that we'll use today.

Run the following code block if you have the `here` package:

```{r source_with_here}
source(here("arenas-02","code", "name_checker.R"))
```

If you have trouble with the `here` package, you can run the following (we'll provide both options throughout this demo):

```{r source_no_here, eval=FALSE}
source(file.path("arenas-02","code", "name_checker.R"))
```

This code gives you a list of parameters that the `name_checker()` function would take:

```{r usage}
args(name_checker)
```

The following are some examples on how we can call this function:

```{r examples, eval=FALSE}
results <- name_checker("my_folder")

results <- name_checker("my_folder", print2screen=FALSE)

detailed <- name_checker("my_folder", verbose=TRUE)
```

Above, the user provides a folder (`my_folder`) containing files with names
that should be checked. The `name_checker()` function finds all the image files (ending in .czi .tif or .tiff) and checks their names. 

The first command saves the results to a variable (called `results`), and also
prints it to the screen. This is what we will be using for most of
this demo. 

The second command saves the results to a variable (`results`), but
doesn't print it to screen. This is useful if you don't want to see
the results on screen (especially if there are 100s of files to
process).

The third command provides more information for each file that it
checked, prints it to screen, and also saves it in a variable
(`detailed`). An example of this will be shown later.

### Oliver's demo

There is a file in the `files_test` folder, that is named according to
the Arenas lab convention. We can run the function to  check if it is named correctly.

```{r oliver_test}
results <- name_checker(here("arenas-02",'files_test'))
```

```{r oliver_test_no_here, eval=FALSE}
results <- name_checker(file.path("arenas-02",'files_test'))
```

The function indicates that the file is named according to the proposed
nomenclature

### Carmen's test run

In another folder, we had Carmen and Shanzheng from the Arenas lab try
to name a few files according to the proposed nomenclature. We have
also added some file names that might not perfectly fit. Let's see if
the function was able to check them.

```{r carmen_test}
source(here("arenas-02","code", "name_checker.R"))

results <- name_checker(here("arenas-02","files_Arenas"))
```

```{r carmen_test_no_here}
source(file.path("arenas-02","code", "name_checker.R"))

results <- name_checker(file.path("arenas-02","files_Arenas"))
```

Let's discuss the results.

### Checking multiple folders

This function can be used as part of a larger workflow to check
multiple folders.
The following R code lists all the directory in the current folder
(which will include all three folders with image files), and will run
the function on each of those folders.
Furthermore, it will also save the results into a file called
`name_checking_log.txt` that you can look at once all the folders have been checked

```{r multiFolder, eval=FALSE}
all_dirs  <-  list.dirs(path=file.path("arenas-02"))
for(i in 1:length(all_dirs)){
  logfile  <-  c(paste("Current folder is:",all_dirs[i]),"")
  logfile  <-  c(logfile,name_checker(all_dirs[i]),print2screen=FALSE)
}

write.table(logfile,file.path("arenas-02","name_checking_log.txt"),sep="\n",quote=F,row.names=F,col.names=F)
```

---

## Understanding and tweaking the function

Before we take a look at the code, this is just to remind you of the
nomenclature:

- 8 sections, each separated by an underscore `_`:

1. Experimental name and researcher initials
2. Experiment date and experiment number
3. Condition and replicate number
4. Immunohistochemistry date
5. Dye, antibodies or transcript
6. Image capture date
7. Microscope type
8. Lens, zoom and image number

And to remind you how we run this function:

```{r reminder, eval=FALSE}
results <- name_checker("my_folder")
```

Briefly, the function takes in the folder, and searches for all the
files in that folder. However, it only looks at files that are either
images (.tif) or those generated by the microscope (.lsm or .czi). The
code that does is in on [line 102 of the name_checker.R script](https://github.com/olivertam/NDCN_hackathon/blob/master/arenas-02/code/name_checker.R#L102)

```{r find_files, eval=FALSE}
files <- setdiff(list.files(folder, pattern="\\.czi$ | \\.tif$ | \\.tiff$ | \\.lsm$",full.names = TRUE), list.dirs(recursive = FALSE))

```

You can see a series of "patterns" that the code is looking for. Let's
take one for example:

```
\\.czi$
```

This is a [regular
expression](https://en.wikipedia.org/wiki/Regular_expression), which
is a way to search for a pattern in text. Even if you don't know
anything about regular expression, you might be guess what pattern
it's looking for based on what we expect the code to do.

What it is looking for are item (in this case, files) that end in
".czi". 
- The "." is represented as `\\.` (it's because both back-slashes and
  dots have special meaning in regular expression)
- The "czi" is represented as `czi`
- The `$` indicates the end of the value, so nothing should come
  after it

#### Questions

How many different file extensions is it looking for (hint: the `|`
functions like "or") ?

If you wanted to add more file extensions/type (let's say ".txt"), how
would you change the code?

---

Once it grabs the file name, it tries to split the name into chunks by
treating the underscore as a separator. So if you have `a_b_c`, the
code on [line
126](https://github.com/olivertam/NDCN_hackathon/blob/master/arenas-02/code/name_checker.R#L126)
will break it up into `a`, `b`, and `c`

```{r breaking_into_chunks, eval=FALSE}
file_info = unlist(strsplit(name, "_", fixed=TRUE))
```

#### Question

If you decided that you want to break that information using commas as
a separator, how would you change the code?

*Note*: This is, in essence, how many programs (e.g. Excel) turn a csv
(comma separated values) file into a table of "cells", though they
have additional checks for the "unusual" cases.

---

After splitting it into chunks, most of the code coming after is about
processing that chunk of information. In most cases, there isn't much
to do other than making sure that it's not empty. 

One "feature" that is in the code is to turn all gene symbols into
upper-case. This affects the 

There are a few things that it checks for, but one thing that it does
is to find the gene symbol (if present), and capitalize it. This
makes sense for protein nomenclature, but sometimes you want prefer
having it with only first letter capitalized.

How would you change that?

### Combining code

We have another piece of code that would capitalize the first letter
of any word:

```{r source_firstCaps}
source(here("arenas-02","code","firstCaps.R"))
```

```{r source_firstCaps_no_here, eval=FALSE}
source(file.path("arenas-02","code","firstCaps.R"))
```

```{r firstCaps_demo}
args(firstCaps)

firstCaps("NURR1")
firstCaps("ras")
```

How would we add this into our function?

Let's head back into [`name_checker.R`](https://github.com/olivertam/NDCN_hackathon/blob/master/arenas-02/code/name_checker.R)

If we head to [line
92](https://github.com/olivertam/NDCN_hackathon/blob/master/arenas-02/code/name_checker.R#L92),
we find a function called `toupper()` there. 
Based on the name, what do you think the function does?

```{r toupper_test}
args(toupper)
toupper("NURR1")
toupper("ras")
```

*Note*: You also see this function on [line 88](https://github.com/olivertam/NDCN_hackathon/blob/master/arenas-02/code/name_checker.R#L88)

So now we find where the code is making things uppercase. How would we
change it to first caps?

First, we want to copy the code into the `name_check.R` script (which we
will save as a new copy called `name_checker_firstCaps.R`). I like to
paste it at the top.

Then we will change the code to use the `firstCaps()` function instead
of `toupper()`, and then save the file.

```{r firstCaps_change, eval=FALSE}
target = substr(antibodies[i],3,nchar(antibodies[i]))
if(grepl("^p[A-Z]",target)){
    ## Possible phosphorylated protein
    ## Converts the expected gene name to all uppercase,
    ##  but keeping the lower case "p" to indicate phosphorylated
    target = paste0("p",firstCaps(substr(target,2,nchar(target))))
}
else{
    ## This converts the expected gene name to all uppercase
    target = firstCaps(target)
}
```

Let's see what the code does now:

```{r firstCaps_nameChecker_source}
source(here("arenas-02","code","name_checker_firstCaps.R"))
```

```{r firstCaps_nameChecker_no_here, eval=FALSE}
source(file.path("arenas-02","code","name_checker_firstCaps.R"))
```

```{r firstCaps_nameChecker_demo}
results <- name_checker(file.path("arenas-02","files_test","Good_file"))
```

Now you can see that the function is suggesting to rename the gene
symbols to only capitalize the first letter.

We hope that this might demonstrate how you can tweak and/or combine
pieces of code from different sources, and make a new piece of code
that would do what you want to do.

#### Is this just a name checker?

If we take a look at the third file, even though the function says that
it's named correctly, sometimes you might want to check what it's
actually finding. The code also has a way to do this by invoking the
`verbose` option:

```{r verbose}
results  <- name_checker(here("arenas-02","files_test","Good_file"),verbose=TRUE)
```

```{r verbose_no_here}
results  <- name_checker(file.path("arenas-02","files_test","Good_file"),verbose=TRUE)
```

From the results, you can see that it identified the following:
1. Destination folder
2. Experimental condition
3. Replicate number
4. Dye, antibody or transcripts being detected
5. Date of image capture
6. Type of microscope used
7. Lens used
8. Zoom level
9. Picture number

This information could be used in the future to auto-generate a
metadata file, or provide a way to "randomize" the file names.
